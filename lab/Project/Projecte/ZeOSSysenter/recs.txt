implementacions:

-milestones en ordre si o si

**MEM DINÁMICA

-memoria dinamica que es pugui escollir la mida ofc -> implementer sbrk(size), size en bytes
**espai de dirs de zeos:
code + data kernel fins 0x100000, despres code + data user, hem de fer tercer a secció heap al final
en tp buscar pagina lliure
de la pag lliure (4096B) utilitzem els bytes de size, nomes demanar una altre pagina si passa de la mida 4096
guardar en la tornada de sbrk el punter a el top de memoria (adreça mes baixa)

en el fork s'ha e copiar el heap tmb
en l'exit alliberar el heap



**PANTALLA
int spritePut(int posX, int posY, Sprite* sp);
coloquem el sprite sp, de manera que el pixel de esquerra adalt a la pantalla

sprite X*Y:
------
|....|
|....|
|....|
------

***THREADS

Threads del mateix proces tenen la mateixa mem-> MATEIXA TP

int threadCreate( void (*function)(void* arg), void* parameter )
mateix espai de mem que el thread k l'invoca
es duplica la pila syst, hem e modificar el cntx hw donat per a que retorni a la funcio del paramtre
i canviar la pila usuari per a empilar el parametre -> nova regio de memoria al final: stack1 (usuari) -> assignar una nova pagina

void threadExit(void)
alliberar tots els recursos donats al thread

**SYNC: SEMÀFORS:
